[
    {
        "question": "A fejlesztői teszt lépéseinek helyes sorrendje:",
        "correct_answer": "d",
        "options": [
            "a. rendszerteszt, integrációs teszt, egységteszt",
            "b. integrációs teszt, egységteszt, rendszerteszt",
            "c. egységteszt, rendszerteszt, integrációs teszt",
            "d. egységteszt, integrációs teszt, rendszerteszt"
        ],
        "question_counter": 1
    },
    {
        "question": "A tesztelés...",
        "correct_answer": "d",
        "options": [
            "a. …garantálja, hogy a program hibamentes.",
            "b. …célja fordítási időben felderíteni a hibákat.",
            "c. …garantálja, hogy a program minden körülmény között helytáll.",
            "d. …futási idejű hibák, rendellenességek, kompatibilitási problémák keresésére használatos."
        ],
        "question_counter": 2
    },
    {
        "question": "Mely állítás hamis?",
        "correct_answer": "d",
        "options": [
            "a. Az integrációs és rendszer­tesztek első lépése a füstteszt.",
            "b. A kiadásteszt és a felhasználói teszt során a szoftvernek már általában a cél­környezetben, tényleges adatokkal kell dolgoznia.",
            "c. A tesztgyűjtemények által letesztelt programkód mértékét nevezzük kódlefedettségnek.",
            "d. A kiadásteszt nem foglalja magába a kihelyezést (pl. telepítés)."
        ],
        "question_counter": 3
    },
    {
        "question": "Az alábbiak közül melyik egy Lehman-törvény?",
        "correct_answer": "d",
        "options": [
            "a. Egy szoftvert folyamatosan használni kell, hogy folyamatosan nőjön a használhatósága és minősége.",
            "b. Egy szoftvert folyamatosan használni kell, vagy különben folyamatosan csökken a használhatósága és minősége.",
            "c. Egy szoftvernek változnia kell, hogy folyamatosan csökkenjen a használhatósága és minősége.",
            "d. Egy szoftvernek változnia kell, vagy különben folyamatosan csökken a használhatósága és minősége."
        ],
        "question_counter": 4
    },
    {
        "question": "Mely állítás igaz?",
        "correct_answer": "b",
        "options": [
            "a. A füsttesztet a tápegységből felszálló füst mennyiségének mérésével végzik.",
            "b. A felhasználói teszt jellemzően fekete doboz tesztekből áll.",
            "c. A kiadás­tesztet a fejlesztő csapat végzi.",
            "d. A fejlesztői teszt jellemzően fekete doboz tesztekből áll."
        ],
        "question_counter": 5
    },
    {
        "question": "Melyik nem fejlesztői teszt?",
        "correct_answer": "a",
        "options": [
            "a. kiadásteszt (release test)",
            "b. integrációs teszt (integration test)",
            "c. egységteszt (unit test)",
            "d. rendszerteszt (system test)"
        ],
        "question_counter": 6
    },
    {
        "question": "Mi a célja a folyamatos integrációs (continuous integration, CI) gyakorlati módszernek?",
        "correct_answer": "d",
        "options": [
            "a. A manuális tesztelés teljes kiváltása.",
            "b. Az elbukott integrációs tesztek automatikus újra futtatása, ameddig meg nem javulnak.",
            "c. Objektum orientált programozási nyelvre való átállást segíti elő.",
            "d. A lehetséges hibák, integrációs problémák azonnali, automatizált kiszűrése, visszajelzés a fejlesztőnek."
        ],
        "question_counter": 7
    },
    {
        "question": "Mi a folyamatos teljesítés (continuous delivery) célja?",
        "correct_answer": "d",
        "options": [
            "a. A folyamatos kiadások automatizálása.",
            "b. Az önszerveződő, kis csapatok folytonos interakciójának biztosítása gyors visszajelzésekkel.",
            "c. A programkódok egy központi tárhelyre küldése, verziókezelő rendszer segítségével, naponta többször.",
            "d. A gyors alkalmazásfejlesztés megvalósítása, inkrementális alapon."
        ],
        "question_counter": 8
    },
    {
        "question": "Hogy hívjuk a folyamatos integráció és teljesítés egymásra épülő feladatait?",
        "correct_answer": "b",
        "options": [
            "a. task",
            "b. job",
            "c. milestone",
            "d. module"
        ],
        "question_counter": 9
    },
    {
        "question": "Milyen nyelven írható le a GitLab CI/CD konfigurációja?",
        "correct_answer": "a",
        "options": [
            "a. YAML",
            "b. XAML",
            "c. JSON",
            "d. XML"
        ],
        "question_counter": 10
    },
    {
        "question": "Mely állítás nem igaz a container framework-ökre (pl. Docker)?",
        "correct_answer": "d",
        "options": [
            "a. A containerek saját, elkülönített, virtualizált környezetben futnak.",
            "b. A containerekben futó alkalmazások belső hálózati kapcsolaton kommunikálhatnak egymással.",
            "c. Minden container osztozik a gazda számítógép hardveres erőforrásain.",
            "d. A containerek futó alkalmazások annak saját virtuális operációs rendszerén (pl. Docker OS) futnak."
        ],
        "question_counter": 11
    },
    {
        "question": "Mely tulajdonságok jellemzőek a Clean Code-ra?",
        "correct_answer": "c",
        "options": [
            "a. Olvasható, tömör, öndokumentáló",
            "b. Könnyen olvasható, nem tartalmaz kódismétlést, tesztelhető",
            "c. Olvasható, karbantartható, tesztelhető, elegáns",
            "d. Jól dokumentált, tesztelt, elegáns"
        ],
        "question_counter": 12
    },
    {
        "question": "Melyik koncepció része a Clean Code-nak?",
        "correct_answer": "a",
        "options": [
            "a. Ugyanazt a nevet ne használjuk különböző célra",
            "b. Rövidítsük mindig a változó neveket",
            "c. A break és continue utasításokat elővigyázatosan kell alkalmaznunk.",
            "d. Használjunk prefixeket az elnevezéseknél"
        ],
        "question_counter": 13
    },
    {
        "question": "Melyik állítás hamis a metódusokkal kapcsolatban a Clean Code-nál?",
        "correct_answer": "d",
        "options": [
            "a. A megvalósítás férjen rá egy képernyőre.",
            "b. Ne ismételjük önmagunkat a kódban (DRY).",
            "c. A blokkoknak egyértelmű be- és kilépési pontja kell legyen (break, continue nem megengedett).",
            "d. Egy metódus több absztrakciós szintet is megvalósíthat."
        ],
        "question_counter": 14
    },
    {
        "question": "Melyik fajta kommentet kerüljük?",
        "correct_answer": "c",
        "options": [
            "a. Következményre figyelmeztető komment",
            "b. TODO",
            "c. Kikommentelt kód",
            "d. Szándékot, pontosítást tartalmazó komment"
        ],
        "question_counter": 15
    },
    {
        "question": "Mi NEM jellemző oka a megírt kód folytonos változásának?",
        "correct_answer": "d",
        "options": [
            "a. követelmény változások",
            "b. hibajavítások",
            "c. új funkciók bevezetése",
            "d. kód minőségének javítása"
        ],
        "question_counter": 16
    },
    {
        "question": "Melyik tervmintát soroltuk rossz osztályba?",
        "correct_answer": "d",
        "options": [
            "a. Felelősséglánc – Viselkedési minta",
            "b. Építő – Létrehozási minta",
            "c. Egyke – Létrehozási minta",
            "d. Pehelysúlyú – Viselkedési minta"
        ],
        "question_counter": 17
    },
    {
        "question": "Melyik NEM LÉTEZŐ tervminta osztály?",
        "correct_answer": "b",
        "options": [
            "a. Szerkezeti",
            "b. Végrehajtási",
            "c. Viselkedési",
            "d. Létrehozási"
        ],
        "question_counter": 18
    },
    {
        "question": "Melyik tervezési mintát alkalmazhatjuk abban az esetben, ha egy adott osztály példányosítását szeretnénk a hozzátartozó alosztályokra áthárítani?",
        "correct_answer": "b",
        "options": [
            "a. Observer (Megfigyelő)",
            "b. Factory method (Gyártó függvény)",
            "c. Command (Parancs)",
            "d. Builder (Építő)"
        ],
        "question_counter": 19
    },
    {
        "question": "Melyik tervezési mintát alkalmazhatjuk abban az esetben, ha konkrét osztály megadása nélkül szeretnénk kapcsolódó vagy egymástól függő objektumok családjának létrehozására felületet biztosítani?",
        "correct_answer": "d",
        "options": [
            "a. Adapter (Illesztő)",
            "b. Factory method (Gyártó függvény)",
            "c. Builder (Építő)",
            "d. Abstract Factory (Absztrakt gyár)"
        ],
        "question_counter": 20
    },
    {
        "question": "Melyik tervezési minta alkalmazható a hosszú paraméterlistájú konstruktorok elkerülésére?",
        "correct_answer": "c",
        "options": [
            "a. Observer (Megfigyelő)",
            "b. Factory (Gyártó)",
            "c. Builder (Építő)",
            "d. Command (Parancs)"
        ],
        "question_counter": 21
    },
    {
        "question": "Mely tervminta fordítja le egy osztály interfészét egy kompatibilis másik interfészre?",
        "correct_answer": "b",
        "options": [
            "a. Híd (Bridge)",
            "b. Illesztő (Adapter)",
            "c. Homlokzat (Facade)",
            "d. Helyettes (Proxy)"
        ],
        "question_counter": 22
    },
    {
        "question": "Mely tervminta ad egyszerűsített felületet egy könyvtárhoz, keretrendszerhez stb.?",
        "correct_answer": "a",
        "options": [
            "a. Homlokzat (Facade)",
            "b. Illesztő (Adapter)",
            "c. Helyettes (Proxy)",
            "d. Híd (Bridge)"
        ],
        "question_counter": 23
    },
    {
        "question": "Mely tervminta tudja csökkenteni az objektumok közötti függőségeket?",
        "correct_answer": "b",
        "options": [
            "a. Illesztő (Adapter)",
            "b. Közvetítő (Mediator)",
            "c. Híd (Bridge)",
            "d. Gyártó művelet (Factory method)"
        ],
        "question_counter": 24
    },
    {
        "question": "Mely tervminta ad lehetőséget egy gyűjtemény bejárására anélkül, hogy az elemek ábrázolását ismernénk?",
        "correct_answer": "d",
        "options": [
            "a. Stratégia (Strategy)",
            "b. Emlékeztető (Memento)",
            "c. Közvetítő (Mediator)",
            "d. Bejáró (Iterator)"
        ],
        "question_counter": 25
    },
    {
        "question": "Melyik állítás igaz a RAIL (Resource Allocation Is Initialization) paradigmára vonatkozóan?",
        "correct_answer": "d",
        "options": [
            "a. Jelentése, hogy minden objektum példányosítás megfeleltethető egy erőforrás foglalásnak.",
            "b. Jelentése, a biztonságos memóriakezelés azáltal, hogy a hatókörön kívül került objektumokat a szemétgyűjtő felszabadítja (garbage collection).",
            "c. Jelentése, hogy minden erőforrás foglalás megfeleltethető egy objektum példányosításnak, ezért a paradigma C++ nyelven nem alkalmazható, mert nem csak objektum-orientáltan lehet programozni a nyelvben.",
            "d. Jelentése, hogy a kezelendő erőforrás az osztály invariantása: annak lefoglalására / megnyitására az objektumok létrehozásakor, a felszabadítására / bezárására az objektum megsemmisítésekor kell sor kerüljön."
        ],
        "question_counter": 26
    },
    {
        "question": "Mi a különbség a folyamat (process) és a szál (thread) között?",
        "correct_answer": "a",
        "options": [
            "a. A folyamatoknak saját végrehajtási környezetük (pl. memóriaterület) van, a szálak osztozkodnak ezen.",
            "b. Nincs különbség, a kettő egymás szinonimája.",
            "c. A folyamatokat Linux operációs rendszeren szálaknak hívjuk.",
            "d. Egy szál több folyamatot is tartalmazhat."
        ],
        "question_counter": 27
    },
    {
        "question": "Melyik állítás hamis az std::future<T> típusra?",
        "correct_answer": "c",
        "options": [
            "a. Az std::future<T> típusú típus alkalmas kivételek átadására is szálak között.",
            "b. Egy std::future<T> típus objektum egy ígéret arra, hogy egy T típusú eredmény előállításra kerül majd.",
            "c. Egy std::future<T> típusú objektumba beleírható egy másik szálon majd kiolvasható érték.",
            "d. Az std::future<T> típus objektum nem feltétlen aszinkron végrehajtást jelent."
        ],
        "question_counter": 28
    },
    {
        "question": "Mi a kiéheztetés (starvation)?",
        "correct_answer": "b",
        "options": [
            "a. Olyan logikai hiba, amelynek során egy közös erőforráshoz több szál is egyszerre hozzáférhet, ezzel inkonzisztens állapotba juttatva a programot.",
            "b. Olyan prioritási hiba, amely esetén a kis prioritású vagy nagy erőforrás-igényű folyamatok sosem képesek lefutni.",
            "c. Olyan ütemezési hiba, amely során egy erőforrásra több szál is várakozik és egyikük sem jut soha hozzá, így “lefagy” a program.",
            "d. Olyan jogosultság-kezelési hiba, amely során egy szál nem tudja a szükséges erőforrásokat (pl. fájlokat) megnyitni."
        ],
        "question_counter": 29
    },
    {
        "question": "Melyik állítás igaz a kölcsönös kizárásra (mutual exclusion)?",
        "correct_answer": "c",
        "options": [
            "a. A kölcsönös kizárás célja a szálak szinkronizációja: a kritikus szakasz mindig ugyanazon a szálon fusson le.",
            "b. Nincsen olyan többszálú program, amely kölcsönös kizárás nélkül helyesen tud működni.",
            "c. A kölcsönös kizárás garantálja, hogy a közös erőforráshoz egyszerre csak egy szál férhessen hozzá, kizárva ezzel a versenyhelyzetet (race condition).",
            "d. A kölcsönös kizárás célja, hogy a többszálú program egyszerre mindig csak egy szál futhasson."
        ],
        "question_counter": 30
    },
    {
        "question": "Melyik állítás igaz a napi Scrum-ra?",
        "correct_answer": "d",
        "options": [
            "a. A napi Scrum-megbeszélésen bárki részt vehet és beszélhet a Scrum Master-rel jelentkezéses alapon.",
            "b. A napi Scrum során az a cél, hogy felszámoljuk a csapatot érintő akadályokat.",
            "c. A napi Scrum-megbeszélés célja, hogy a maximum 1 órára hosszúra korlátozott megbeszélés során a Scrum Master megismerje, hogy ki mennyit haladt a projekttel az előző megbeszélés óta.",
            "d. A napi Scrum-megbeszélés célja, hogy a Scrum csapat tagjai összehangolják tevékenységüket. A megbeszélés ideje maximum 15 percre korlátozott."
        ],
        "question_counter": 31
    },
    {
        "question": "Melyik állítás igaz a Scrum master-re?",
        "correct_answer": "a",
        "options": [
            "a. A Scrum master a folyamatokért felel.",
            "b. A Scrum master vezeti a napi Scrumot.",
            "c. A Scrum master nem felel azért, hogy külső hatásoktól védje a Scrum csapat munkáját.",
            "d. A Scrum master a Scrum csapat menedzsere."
        ],
        "question_counter": 32
    },
    {
        "question": "Melyik lineáris szoftverfejlesztési modell az alábbiak közül?",
        "correct_answer": "c",
        "options": [
            "a. Scrum",
            "b. Kanban",
            "c. Waterfall (Vízésés)",
            "d. Spiral (Spirális)"
        ],
        "question_counter": 33
    },
    {
        "question": "A három Scrum-termék (artifacts) a következő:",
        "correct_answer": "c",
        "options": [
            "a. termék kívánságlista (product backlog), Scrum tábla (Scrum table), haladási diagram (progress diagram)",
            "b. termékvízió (product vision), termék kívánságlista (product backlog), felhasználói történet (user story)",
            "c. termék kívánságlista (product backlog), futam teendőlista (sprint backlog), inkrementum (increment)",
            "d. termék kívánságlista (product backlog), futam teendőlista (sprint backlog), Scrum tábla (Scrum table)"
        ],
        "question_counter": 34
    },
    {
        "question": "Melyik nem agilis szoftverfejlesztési módszertan szerinti modell az alábbiak közül?",
        "correct_answer": "c",
        "options": [
            "a. Scrum",
            "b. Lean",
            "c. Rational Unified Process (RUP)",
            "d. Kanban"
        ],
        "question_counter": 35
    },
    {
        "question": "Melyik nem iteratív szoftverfejlesztési módszertan szerinti modell az alábbiak közül?",
        "correct_answer": "c",
        "options": [
            "a. Spiral (Spirális)",
            "b. Scrum",
            "c. Kanban",
            "d. Extreme Programming (XP)"
        ],
        "question_counter": 36
    },
    {
        "question": "Mi az előadáson elmondott planning poker?",
        "correct_answer": "a",
        "options": [
            "a. projektmenedzsment becslési módszere",
            "b. kártyajáték",
            "c. szerencsejáték",
            "d. szoftver tervezésének becslési módszere"
        ],
        "question_counter": 37
    },
    {
        "question": "Mely állítás igaz a verifikációval kapcsolatban?",
        "correct_answer": "d",
        "options": [
            "a. A statikus elemzés ellenére nem garantált a hibák egymás általi elfedése.",
            "b. A statikus elemzés a teljes programkód ismeretében végezhető el.",
            "c. A dinamikus elemzés nem alkalmas a program teljesítményének mérésére.",
            "d. A dinamikus elemzés felfedheti a programegységek együttműködéséből származó hibákat."
        ],
        "question_counter": 38
    },
    {
        "question": "A tesztelés...",
        "correct_answer": "c",
        "options": [
            "a. …célja fordítási időben felderíteni a hibákat.",
            "b. …garantálja, hogy a program minden körülmény között helytáll.",
            "c. …futási idejű hibák, rendellenességek, kompatibilitási problémák keresésére használatos.",
            "d. …garantálja, hogy a program hibamentes."
        ],
        "question_counter": 39
    },
    {
        "question": "Mely állítás igaz?",
        "correct_answer": "a",
        "options": [
            "a. A felhasználói teszt jellemzően fekete doboz tesztekből áll.",
            "b. A fejlesztői teszt jellemzően fekete doboz tesztekből áll.",
            "c. A kiadás tesztet a fejlesztő csapat végzi.",
            "d. A füst tesztet a tápegységből felszálló füst mennyiségének mérésével végzik."
        ],
        "question_counter": 40
    },
    {
        "question": "A folyamatos teljesítés célja...",
        "correct_answer": "a",
        "options": [
            "a. …a gyors alkalmazásfejlesztés megvalósítása, inkrementális alapon.",
            "b. …a folyamatos kiadások automatizálása.",
            "c. …az önszerveződő, kis csapatok folytonos interakciójának biztosítása gyors visszajelzésekkel.",
            "d. …hogy a programkódok verziókezelő rendszer segítségével egy központi tárhelyre kerüljenek, naponta többször."
        ],
        "question_counter": 41
    },
    {
        "question": "Az alábbiak közül melyik nincs kapcsolatban a folyamatos integrációval?",
        "correct_answer": "d",
        "options": [
            "a. AppVeyor",
            "b. Travis",
            "c. GitLab",
            "d. JetLag"
        ],
        "question_counter": 42
    },
    {
        "question": "Melyik NEM része a TDD három alapszabályának?",
        "correct_answer": "b",
        "options": [
            "a. Csak annyi kódot írjunk, amennyi éppen elegendő a sikeres teszthez.",
            "b. A sikeres tesztelést mindig refaktorálás követi.",
            "c. Tesztből csak éppen elegendő mértékűt írjunk a hiba demonstrálásához.",
            "d. NE kódoljunk semmit, kivéve ami ahhoz kell, hogy a programunk átmenjen a sikertelen teszten."
        ],
        "question_counter": 43
    },
    {
        "question": "Mi igaz a TDD elvű fejlesztésre?",
        "correct_answer": "b",
        "options": [
            "a. A végső kódnak elegendő jól működnie az utoljára bevezetett tesztesetekben.",
            "b. A tesztek a lehetséges használati eseteknek csak egy részhalmazát fedik le.",
            "c. Elegendő, ha csak annyit kódolunk, ami pillanatnyilag szükséges.",
            "d. Vég eredményként egy strukturált kódot kapunk, ami kielégíti a teszteket, de még esetlegesen refaktorálásra szorul."
        ],
        "question_counter": 44
    },
    {
        "question": "Melyik állítás igaz a Clean Code-al kapcsolatban?",
        "correct_answer": "b",
        "options": [
            "a. A függvények egyszerre valaszolhatnak egy kérdésre és hajthatnak végre valamit.",
            "b. A kód és a komment nem feltétlenül él együtt.",
            "c. Hibakódokat és kivételeket egyaránt használunk.",
            "d. A komment segít a nehezen érthető kódot megérteni."
        ],
        "question_counter": 45
    },
    {
        "question": "Mely szál futtatja az eseménykezelésért felelős tevékenységeket?",
        "correct_answer": "c",
        "options": [
            "a. ELT",
            "b. DBT",
            "c. EDT",
            "d. DDT"
        ],
        "question_counter": 46
    },
    {
        "question": "Melyik nem létező szálállapot?",
        "correct_answer": "c",
        "options": [
            "a. Resumed",
            "b. Suspended",
            "c. Stopped",
            "d. Running"
        ],
        "question_counter": 47
    },
    {
        "question": "Mi a szálak alapértelmezett prioritása?",
        "correct_answer": "c",
        "options": [
            "a. 1",
            "b. 0",
            "c. 5",
            "d. 10"
        ],
        "question_counter": 48
    },
    {
        "question": "A Thread objektum mely metódusával indítható el új szál?",
        "correct_answer": "a",
        "options": [
            "a. start",
            "b. spawn",
            "c. run",
            "d. execute"
        ],
        "question_counter": 49
    },
    {
        "question": "Mely metódussal tud egy szál lemondani a CPU-időről?",
        "correct_answer": "a",
        "options": [
            "a. sleep",
            "b. interrupt",
            "c. suspend",
            "d. wait"
        ],
        "question_counter": 50
    },
    {
        "question": "Egy szál mely metódusának meghívásával lehet megvárni a szál befejeződését?",
        "correct_answer": "d",
        "options": [
            "a. await",
            "b. stop",
            "c. wait",
            "d. join"
        ],
        "question_counter": 51
    },
    {
        "question": "Mit jelent párhuzamos környezetben a kiéheztetés?",
        "correct_answer": "d",
        "options": [
            "a. A szálak nem mondanak le a használt erőforrásaikról.",
            "b. Mire a program hajlandó befejeződni, a felhasználó már régen éhen halt.",
            "c. A párhuzamos program szálai nem tudnak elindulni, mert az operációs rendszer korábban zombi állapotba került.",
            "d. Egy szál nem tud hozzáférni a kívánt erőforráshoz huzamosabb ideig, mert más, hosszú futásidejű szálak korábban kapják azt meg."
        ],
        "question_counter": 52
    },
    {
        "question": "Egy lock-ként használt objektum mely metódusával ébreszthető fel az arra várakozó szál?",
        "correct_answer": "a",
        "options": [
            "a. notify",
            "b. wake",
            "c. wait",
            "d. spotify"
        ],
        "question_counter": 53
    },
    {
        "question": "Mi igaz egy immutable objektumra?",
        "correct_answer": "d",
        "options": [
            "a. Az objektumban attribútumai nem változtathatók meg, de a referenciák esetében a rajtuk keresztül elérhető objektumokon ez megengedett.",
            "b. Attribútumai csak setter metódusok segítségével változtathatók meg.",
            "c. Az objektumban nem tárolhatunk referenciát más objektumokra.",
            "d. Az objektum állapota nem változtatható meg a konstruktor lefutása után."
        ],
        "question_counter": 54
    },
    {
        "question": "Mely tervmintával csökkenthetjük a szükséges memóriát úgy, hogy megosztjuk az állapot közös részeit több objektum között egy új objektumban?",
        "correct_answer": "a",
        "options": [
            "a. Pehelysúlyú (Flyweight)",
            "b. Összetétel (Composite)",
            "c. Illesztő (Adapter)",
            "d. Helyettes (Proxy)"
        ],
        "question_counter": 55
    },
    {
        "question": "Mely tervminta teszi lehetővé a kérések továbbítását a kezelők lánca mentén? [AI GENERALT]",
        "correct_answer": "a",
        "options": [
            "a. Felelősséglánc (Chain of Responsibility)",
            "b. Híd (Bridge)",
            "c. Közvetítő (Mediator)",
            "d. Építő (Builder)"
        ],
        "question_counter": 56
    },
    {
        "question": "A következők közül melyik NEM tartozik a szoftver evolúció három karbantartási típusának egyikébe? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. perfective maintenance (tökéletesítő karbantartás)",
            "b. adaptive maintenance (adaptív karbantartás)",
            "c. predictive maintenance (előrejelző karbantartás)",
            "d. corrective maintenance (hibajavítás)"
        ],
        "question_counter": 57
    },
    {
        "question": "Melyik állítás HAMIS a Lehman-törvényekkel kapcsolatban? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. A szoftvernek változnia kell, vagy különben folyamatosan csökken a használhatósága és minősége.",
            "b. A változó szoftver egyre összetettebb lesz és egyre több funkciót tartalmaz.",
            "c. Az evolúciós folyamatban a rendszer tulajdonságai (méret, hibák száma) szorosan követik a kiadások sorrendjét.",
            "d. Az evolúciós folyamat önszabályozó, és a rendszer tulajdonságai függetlenek az egyes kiadástól."
        ],
        "question_counter": 58
    },
    {
        "question": "Az alábbi viselkedési minták közül melyik teszi lehetővé, hogy egy objektumstruktúrához új műveleteket adjunk anélkül, hogy az eredeti osztályokat módosítanánk? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. Strategy (Stratégia)",
            "b. Observer (Megfigyelő)",
            "c. Visitor (Látogató)",
            "d. Composite (Összetétel)"
        ],
        "question_counter": 59
    },
    {
        "question": "C++-ban melyik konstrukció biztosítja egy std::mutex egyszerű, RAII-stílusú rövid idejű zárolását? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. std::mutex::lock() és std::mutex::unlock()",
            "b. std::lock_guardstd::mutex",
            "c. std::unique_lockstd::mutex defer_lock nélkül",
            "d. std::scoped_lock, ha nem adunk meg mutex-eket"
        ],
        "question_counter": 60
    },
    {
        "question": "Mi a std::packaged_task célja a C++ multithreading támogatásában? [AI GENERALT]",
        "correct_answer": "a",
        "options": [
            "a. Egy callable objektumot egy std::future-hez köt, lehetővé téve az eredmény aszinkron lekérdezését.",
            "b. Több szál egyesítését biztosítja egy közös futtatókörnyezetbe.",
            "c. Automatikusan újrafuttatja a hibás thread-et, amíg sikeres nem lesz.",
            "d. Zárolja a kritikus szakaszt a lock() metódus meghívásakor."
        ],
        "question_counter": 61
    },
    {
        "question": "Melyik fájlformátumban definiáljuk a GitLab CI/CD konfigurációját? [AI GENERALT]",
        "correct_answer": "a",
        "options": [
            "a. .gitlab-ci.yml",
            "b. .travis.yml",
            "c. Jenkinsfile",
            "d. azure-pipelines.yml"
        ],
        "question_counter": 62
    },
    {
        "question": "Mi a fő különbség a Docker konténerek és a virtualizált virtuális gépek között? [AI GENERALT]",
        "correct_answer": "a",
        "options": [
            "a. A konténerek osztoznak a gazda gép kerneljén, míg a VM-ek teljes operációs rendszert virtualizálnak.",
            "b. A konténerek külön kernel-t futtatnak minden példányban.",
            "c. A VM-ek kisebb overhead-del rendelkeznek a konténerekhez képest.",
            "d. A konténerek csak Windows rendszeren futtathatók."
        ],
        "question_counter": 63
    },
    {
        "question": "Melyik állítás NEM jellemző a Clean Code-ra az előadáson ismertetett tulajdonságok alapján? [AI GENERALT]",
        "correct_answer": "d",
        "options": [
            "a. Olvasható",
            "b. Karbantartható",
            "c. Tesztelhető",
            "d. Gazdagon dokumentált"
        ],
        "question_counter": 64
    },
    {
        "question": "Melyik nem része a Scrum eseményeinek? [AI GENERALT]",
        "correct_answer": "d",
        "options": [
            "a. Futam tervezés",
            "b. Napi Scrum",
            "c. Visszatekintés",
            "d. Termék kívánságlista finomítás (backlog refinement)"
        ],
        "question_counter": 65
    },
    {
        "question": "Melyik állítás igaz a statikus kódelemzésre? [AI GENERALT]",
        "correct_answer": "a",
        "options": [
            "a. A forráskód fordítás előtt képes feltárni lehetséges hibákat és kódstílus-eltéréseket.",
            "b. A futás közbeni memóriaszivárgás detektálására szolgál.",
            "c. A program dinamikus viselkedését modellezi tesztadatokkal.",
            "d. A unit tesztek futtatását végzi."
        ],
        "question_counter": 66
    },
    {
        "question": "Mi a GoF definíciója a szoftver tervezési mintára? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. Egy nyelvi könyvtár, amely újrafelhasználható komponenseket biztosít.",
            "b. Olyan egymással együttműködő objektumok és osztályok leírása, amelyek testre szabott formában valamilyen általános tervezési problémát oldanak meg egy bizonyos összefüggésben.",
            "c. Egy automatikus kódgeneráló eszköz a tervezési feladatokhoz.",
            "d. Egy UML-diagram készítő minta."
        ],
        "question_counter": 67
    },
    {
        "question": "Mely viselkedési minta teszi lehetővé, hogy egy algoritmus egyes lépéseit előre definiáljuk, ugyanakkor bizonyos lépéseket az alosztályokra ruházzunk át implementációra? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. Strategy (Stratégia)",
            "b. Observer (Megfigyelő)",
            "c. Template Method (Sablonfüggvény)",
            "d. Visitor (Látogató)"
        ],
        "question_counter": 68
    },
    {
        "question": "Mely létrehozási minta kezeli az objektumok magas létrehozási költségét úgy, hogy előre inicializált példányok csoportját tartja használatra készen? [AI GENERALT]",
        "correct_answer": "a",
        "options": [
            "a. Object Pool (Objektumkészlet)",
            "b. Prototype (Prototípus)",
            "c. Singleton (Egyke)",
            "d. Factory Method (Gyártófüggvény)"
        ],
        "question_counter": 69
    },
    {
        "question": "Mi a Double-Checked Locking minta (DCLP) fő problémája a Singleton inicializálása során C++-ban? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. A lock_guard nem oldja fel megfelelően a zárolást.",
            "b. A lock előtti és utáni resource_ptr ellenőrzés nincs megfelelően szinkronizálva, ami versenyhelyzethez vezethet.",
            "c. A std::call_once nem garantálja az inicializáló függvény egyszeri futását.",
            "d. A Meyers Singleton C++11 előtti verziókban nem működik."
        ],
        "question_counter": 70
    },
    {
        "question": "Melyik nem típusú executor a GitLab Runner számára? [AI GENERALT]",
        "correct_answer": "d",
        "options": [
            "a. Shell",
            "b. SSH",
            "c. Kubernetes",
            "d. Jenkins"
        ],
        "question_counter": 71
    },
    {
        "question": "A .gitlab-ci.yml fájlban mi a dependencies szekció szerepe? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. A pipeline szakaszok (stages) sorrendjének meghatározása.",
            "b. A build kép elkészítésének konfigurálása.",
            "c. Artifactok megosztása a jobok között, hogy a ráépülő jobok hozzáférjenek a korábbi kimenetekhez.",
            "d. Futtatási környezeti változók definiálása."
        ],
        "question_counter": 72
    },
    {
        "question": "Mire szolgál a cache szekció a GitLab CI/CD konfigurációjában? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. Változók definiálására a jobok futtatási környezetében.",
            "b. Cache-elt fájlok és könyvtárak megőrzésére pipeline-ok és jobok között a függőségek gyorsabb letöltéséhez.",
            "c. Service konténerek konfigurálására.",
            "d. Artifacts időkorlát nélküli megőrzésére."
        ],
        "question_counter": 73
    },
    {
        "question": "A tesztvezérelt fejlesztés (TDD) melyik lépés következik közvetlenül a teszteset megírása után? [AI GENERALT]",
        "correct_answer": "d",
        "options": [
            "a. Refaktorálás",
            "b. A teszteset futtatása",
            "c. A termékkövetelmények dokumentálása",
            "d. Az implementáció megvalósítása"
        ],
        "question_counter": 74
    },
    {
        "question": "A C++ std::condition_variable::wait második paramétereként átadott lambdafüggvény szerepe: [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. Automatikusan újrazárolja a mutexet minden ébredéskor.",
            "b. Csak akkor tér vissza, amikor a lambdafüggvény true értéket ad, ezzel elkerülve a véletlenszerű ébredéseket (spurious wake).",
            "c. Az ébredéskor automatikusan újraindítja a producer szálat.",
            "d. A lambdafüggvény a mutex felszabadítását végzi."
        ],
        "question_counter": 75
    },
    {
        "question": "A hibajavítás költsége a hiba felfedezésének helye függvényében melyik esetben a legmagasabb? [AI GENERALT]",
        "correct_answer": "d",
        "options": [
            "a. Követelmények specifikációkor",
            "b. Tervezés során",
            "c. Implementációkor",
            "d. Üzemeltetéskor"
        ],
        "question_counter": 76
    },
    {
        "question": "Mi történik az Objektumkészlet (Object Pool) mintában, amikor a kliens befejezte az objektum használatát? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. Az objektumot megsemmisítjük és eltávolítjuk a készletből.",
            "b. Visszarakjuk az objektumot a készletbe későbbi újrafelhasználásra.",
            "c. Klónozunk egy új példányt minden használatkor.",
            "d. A kliens blokkolódik, amíg új objektum nem érkezik."
        ],
        "question_counter": 77
    },
    {
        "question": "Melyik állítás jellemzi legpontosabban a Sablonfüggvény (Template Method) mintát? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. Egy osztály interfészét illeszti át más kompatibilis interfészre.",
            "b. Meghatározza egy algoritmus általános lépéseit, és az egyes lépések implementálását az alosztályokra bízza.",
            "c. Automatikusan hozza létre az objektumok példányait egy központi tárolóból.",
            "d. Egyetlen metódusban gyűjti össze az összes implementációt."
        ],
        "question_counter": 78
    },
    {
        "question": "Mi az Absztrakt Gyár (Abstract Factory) minta fő előnye a kliensoldali kód számára? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. Lehetővé teszi, hogy egyetlen gyártófüggvény többféle típusú objektumot hozzon létre.",
            "b. Elrejti a platformfüggő osztályokat, így a kliens nem ismeri a konkrét termékosztályokat.",
            "c. Automatikusan frissíti a gyárat minden új termékelváltozáskor.",
            "d. A gyár és termékosztályok egyetlen osztályban kerülnek deklarálásra."
        ],
        "question_counter": 79
    },
    {
        "question": "Mit ad vissza a C++ std::thread::hardware_concurrency() függvénye? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. A létrehozott szálak maximális száma.",
            "b. A jelenleg futó szálak száma.",
            "c. A párhuzamos végrehajtásra alkalmas hardverprocesszorok száma.",
            "d. A rendszer által támogatott maximális folyamatok száma."
        ],
        "question_counter": 80
    },
    {
        "question": "Mi történik, ha egy std::thread objektumon meghívjuk a detach() metódust? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. A szál azonnal leáll, és a thread objektum nem joinolható.",
            "b. A szál és a thread objektum örökre összekapcsolódik, így biztosított a végrehajtás lezárása.",
            "c. A fizikai szál leválik a thread objektumról, és önállóan, háttérben fut tovább.",
            "d. A detach() hívás helyett automatikusan a join() hívódik meg."
        ],
        "question_counter": 81
    },
    {
        "question": "Melyik NEM GitLab Runner executor típus? [AI GENERALT]",
        "correct_answer": "d",
        "options": [
            "a. Shell",
            "b. SSH",
            "c. Kubernetes",
            "d. VMware"
        ],
        "question_counter": 82
    },
    {
        "question": "Melyik a Windows GitLab Runner-ek alapértelmezett Docker image-e? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. ubuntu:22.04",
            "b. mcr.microsoft.com/windows/servercore:1809",
            "c. alpine:latest",
            "d. centos:7"
        ],
        "question_counter": 83
    },
    {
        "question": "Mi különbözteti meg a folyamatos telepítést (continuous deployment) a folyamatos kiadástól (continuous delivery) a CI/CD gyakorlatban? [AI GENERALT]",
        "correct_answer": "b",
        "options": [
            "a. A continuous delivery automatikusan telepít a tesztkörnyezetbe, míg a continuous deployment manuálisan történik.",
            "b. A continuous deployment az összes sikeres build után automatikusan kiadja a kódot a termelési környezetbe.",
            "c. A continuous delivery azonnali visszajelzést ad a fejlesztőnek, míg a continuous deployment csak napi egyszer fut le.",
            "d. A continuous delivery kizárólag a verziókezelésről szól, a continuous deployment a tesztelésről."
        ],
        "question_counter": 84
    },
    {
        "question": "Melyik állítás NEM jellemző a többszálú programozás során tapasztalható hibákra C++-ban? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. Race condition (versenyhelyzet)",
            "b. Deadlock (holtponthiba)",
            "c. Buffer overflow (puffer túlcsordulás)",
            "d. Starvation (kiéheztetés)"
        ],
        "question_counter": 85
    },
    {
        "question": "Melyik NEM tartozik a Scrum Master feladatkörei közé Mike Cohn szerint? [AI GENERALT]",
        "correct_answer": "c",
        "options": [
            "a. A Scrum események facilitálása és a folyamatokért való felelősségvállalás",
            "b. Az akadályok (impedimentek) eltávolítása a csapat munkájából",
            "c. A csapattagok napi feladatainak kiosztása és menedzselése",
            "d. A külső hatásoktól való védelem biztosítása a Scrum csapat számára"
        ],
        "question_counter": 86
    },
    {
        "question": "Mely állítás szükséges előfeltétele az immutable tulajdonságnak?",
        "correct_answer": "a",
        "options": [
            "a. Az objektum típusú adattagokról mindig másolatot kell készíteni, amikor azt getter metódusból ki kell adni, és ha konstruktor paraméterben átvesszük inicializációhoz.",
            "b. Az osztályt final –ként kell deklarálni a leszármaztatás megelőzése végett.",
            "c. Az osztály összes adattagját private final –ként kell deklarálni.",
            "d. Az osztály tartalmazhat olyan metódust, amely az objektum állapotát a konstruktor lefutása után megváltoztathatja."
        ],
        "question_counter": 87
    },
    {
        "question": "Mely tervezési minta megvalósításának része lehet az alábbi kódrészlet?\npublic MyPattern withName(String name) {\nthis.name = name;\nreturn this;\n}\npublic MyPattern withNumber(int number) {\nthis.number = number;\nreturn this;\n}",
        "correct_answer": "d",
        "options": [
            "a. Adapter (Illesztő)",
            "b. Singleton (Egyke)",
            "c. Command (Parancs)",
            "d. Builder (Építő)"
        ],
        "question_counter": 88
    },
    {
        "question": "Melyik állítás igaz az alábbiak közül?\n1. CallableStatement kiterjeszti a PreparedStatement interface-t. Ez az interface használható SQL tárolt eljárások hívására.\n2. Statement kiterjeszti a PreparedStatement interface-t és akkor használatos, amikor az SQL lekérdezést nem szükséges többször futtatnunk.\n3. PreparedStatement statikus lekérdezések indítására használatos (pl.: select * from table), ezért PreparedStatement-ek nem paraméterezhetőek.\n4. PreparedStatement használatával lehetséges SQL utasítások batch feldolgozása.",
        "correct_answer": "a",
        "options": [
            "a. 1 & 4",
            "b. 2 & 3",
            "c. Egyik sem",
            "d. 1 & 3"
        ],
        "question_counter": 89
    },
    {
        "question": "Melyik nem DML utasítás az alábbi SQL utasítások közül?",
        "correct_answer": "b",
        "options": [
            "a. insert into [table] …",
            "b. alter table …",
            "c. delete from [table] …",
            "d. update [table] set …"
        ],
        "question_counter": 90
    },
    {
        "question": "Mi lesz a következő kód futtatásának eredménye?\npublic class Test extends Thread {\npublic void run() {\nSystem.out.println(isAlive());\n}\npublic static void main(String[] args) {\nTest test = new Test();\nSystem.out.println(test.isAlive());\ntest.start();\n}\n}",
        "correct_answer": "c",
        "options": [
            "a. true true",
            "b. false false",
            "c. false true",
            "d. true false"
        ],
        "question_counter": 91
    },
    {
        "question": "Milyen célt szolgál a GitLab CI cache konfigurációjának kulcsa (key)?",
        "correct_answer": "c",
        "options": [
            "a. Használatával korlátozható, hogy mely jobok férhetnek hozzá a cache-hez.",
            "b. Használatával a cache tartalma artifact-ként letölthetővé tehető.",
            "c. Használatával különálló cache használható akár jobonként vagy fejlesztési ágonként.",
            "d. Használatával megadható a Cache Server elérhetősége, amennyiben nem az alapértelmezettet kívánjuk használni."
        ],
        "question_counter": 92
    },
    {
        "question": "Mi a szálak legalacsonyabb prioritása?",
        "correct_answer": "d",
        "options": [
            "a. 10",
            "b. –10",
            "c. 0",
            "d. 1"
        ],
        "question_counter": 93
    },
    {
        "question": "Melyik megvalósítást válasszuk az alábbi opciók közül, ha olyan gyűjteményt szeretnénk a feladat során használni, mely nem tartalmaz duplikált elemeket és nincs szükségünk arra, hogy az elemeket a beszúrás sorrendjében vagy az értékek szerint növekvő sorrendben tároljuk?",
        "correct_answer": "d",
        "options": [
            "a. TreeSet",
            "b. ArrayList",
            "c. LinkedHashSet",
            "d. HashSet"
        ],
        "question_counter": 94
    },
    {
        "question": "Melyik megvalósítást válasszuk az alábbi opciók közül abban az esetben, ha főleg index alapú keresést szeretnénk alkalmazni egy dinamikusan változó méretű adathalmazon, ahol többször is előfordulhat ugyanaz az elem? (Új elemet csak a gyűjtemény végére szeretnénk helyezni, törölni a gyűjteményből nem szeretnénk gyakran.)",
        "correct_answer": "d",
        "options": [
            "a. HashSet",
            "b. LinkedList",
            "c. Tömb (Array)",
            "d. ArrayList"
        ],
        "question_counter": 95
    },
    {
        "question": "Melyik kapcsolatot szokás kapcsoló táblával leképezni?",
        "correct_answer": "a",
        "options": [
            "a. m – n kapcsolatot",
            "b. Kapcsolt táblás lekérdezést",
            "c. 1 – n kapcsolatot",
            "d. 1 – 1 kapcsolatot"
        ],
        "question_counter": 96
    },
    {
        "question": "Mire való a tranzakció az adatbázisoknál?",
        "correct_answer": "b",
        "options": [
            "a. Tárolt eljárások futtatására.",
            "b. Több művelet atomikénti végrehajtására.",
            "c. Kapcsolt táblás lekérdezésre.",
            "d. Átutalások elnevezésére."
        ],
        "question_counter": 97
    },
    {
        "question": "Melyik tervezési minta valósítja meg az alábbi kódrészletet?\npublic class MyPattern {\nprivate MyPattern(){}\nprivate static class MyPatternInstance {\nprivate static final MyPattern INSTANCE = new MyPattern();\n}\npublic static MyPattern getInstance() {\nreturn MyPatternInstance.INSTANCE;\n}\n}",
        "correct_answer": "d",
        "options": [
            "a. Factory (Gyártó)",
            "b. Builder (Építő)",
            "c. Factory method (Gyártó függvény)",
            "d. Singleton (Egyke)"
        ],
        "question_counter": 98
    },
    {
        "question": "Melyik tervezési minta nyújt megoldást arra a problémára, ha több objektumot szeretnénk értesíteni, amikor egy másik objektumnak megváltozik az állapota?",
        "correct_answer": "d",
        "options": [
            "a. Adapter (Illesztő)",
            "b. Factory (Gyártó)",
            "c. Singleton (Egyke)",
            "d. Observer (Megfigyelő)"
        ],
        "question_counter": 99
    },
    {
        "question": "Mely információ nem nyerhető ki az SQLException objektumból?",
        "correct_answer": "d",
        "options": [
            "a. SQL státuszkód.",
            "b. Driver/adatbázis specifikus hibakód.",
            "c. A felmerült hiba leírása.",
            "d. A hibát okozó adatbázis kérése."
        ],
        "question_counter": 100
    },
    {
        "question": "Melyik output nem lehetséges a következő kód futtatása esetén?\npublic class Tester extends Thread {\nint code = 10;\npublic void run() {\nthis.code = 0;\n}\npublic static void main(String[] args) {\nTester thread = new Tester();\nthread.start();\nfor (int i = 0; i < 5; i++) {\nSystem.out.print(thread.code + \" \");\n}\n}\n}",
        "correct_answer": "a",
        "options": [
            "a. “0 10 10 10 10”",
            "b. “10 0 0 0 0”",
            "c. “10 10 10 10 1”",
            "d. “0 0 0 0 0”"
        ],
        "question_counter": 101
    },
    {
        "question": "Mely tulajdonságok jellemzőek a Clean Code-ra?",
        "correct_answer": "a",
        "options": [
            "a. Olvasható, karbantartható, teszthető, elegáns",
            "b. Olvasható, tömör, öndokumentáló",
            "c. Könnyen olvasható, nem tartalmaz kódismétlést, teszthető",
            "d. Jól dokumentált, tesztelt, elegáns"
        ],
        "question_counter": 102
    },
    {
        "question": "Mi a szálak legmagasabb prioritása?",
        "correct_answer": "a",
        "options": [
            "a. 10",
            "b. 5",
            "c. 1",
            "d. 20"
        ],
        "question_counter": 103
    },
    {
        "question": "Mit támogat a Java az osztályok esetében a többszörös specializáció és többszörös általánosítás közül?",
        "correct_answer": "c",
        "options": [
            "a. Mindkettő",
            "b. Általánosítás",
            "c. Specializáció",
            "d. Egyik sem"
        ],
        "question_counter": 104
    },
    {
        "question": "Melyik koncepció része a Clean Code-nak?",
        "correct_answer": "c",
        "options": [
            "a. A break és continue utasításokat elővigyázatosan kell alkalmaznunk.",
            "b. Használjunk prefixeket az elnevezéseknél.",
            "c. Ugyanazt a nevet ne használjuk különböző célra.",
            "d. Rövidítsük mindig a változó neveket."
        ],
        "question_counter": 105
    },
    {
        "question": "Mi nem része az Egyed-Kapcsolat diagramnak?",
        "correct_answer": "b",
        "options": [
            "a. Entitás",
            "b. Osztály",
            "c. Kulcsok",
            "d. Attribútum"
        ],
        "question_counter": 106
    },
    {
        "question": "Adott egy lámpa (Lamp) osztály. A lámpának van színe, illetve ki/be lehet kapcsolni. A lakásunkban a falon található egy kapcsoló (Switch), mely az alábbi módon lett implementálva.\npublic class Switch {\nprivate Lamp lamp;\npublic Switch(Lamp lamp) {\nthis.lamp = lamp;\n}\npublic void useSwitch(){\nif(lamp.isOn()) {\nlamp.turnOff();\n} else {\nlamp.turnOn();\n}\n}\n}\nMi lehet a probléma ezzel a megvalósítással?",
        "correct_answer": "c",
        "options": [
            "a. A kapcsoló megsérti a Single Responsibility Principle-t (Egy felelősség elve)",
            "b. A kapcsoló megsérti az Open/Closed Principle-t (Nyílt/Zárt elv)",
            "c. A kapcsoló magasabb absztrakciós szinten helyezkedik el, mint a lámpa, így megsérül a Dependency Inversion Principle (Függőségek megfordításának elve)",
            "d. A kapcsoló megsérti a Liskov Substitution Principle-t (Liskov-féle helyettesítési elv)"
        ],
        "question_counter": 107
    },
    {
        "question": "Melyik nem SOLID alapelv az alábbiak közül?",
        "correct_answer": "c",
        "options": [
            "a. Liskov Substitution Principle (Liskov-féle helyettesítési elv)",
            "b. Open/Closed Principle (Nyílt/Zárt elv)",
            "c. Separation of Concerns Principle (A vonatkozások szétvalasztásának elve)",
            "d. Single Responsibility Principle (Egy felelősség elve)"
        ],
        "question_counter": 108
    },
    {
        "question": "Mely gyűjtemény indexelhető?",
        "correct_answer": "b",
        "options": [
            "a. HashMap",
            "b. Vector",
            "c. HashSet",
            "d. TreeMap"
        ],
        "question_counter": 109
    },
    {
        "question": "Mi lehet generikus paraméter?",
        "correct_answer": "d",
        "options": [
            "a. Alaptípus",
            "b. Interface",
            "c. Konstans szám értékek",
            "d. Osztály, ami megvalósítja a generikusban használt műveleteket"
        ],
        "question_counter": 110
    },
    {
        "question": "Mit mond ki a DRY elv?",
        "correct_answer": "c",
        "options": [
            "a. A tökéletességet nem akkor lehet a legjobban megközelíteni, ha egy rendszerhez nem tudunk már semmit hozzáadni, hanem akkor, ha nem tudunk mit elvenni belőle.",
            "b. Az biztosan elmondható, hogy javulni fog a kód bázisunk minősége, ha mindig úgy hagyjuk ott az aktuális kódunkat, hogy az egy kicsit „jobb”, egy kicsit tisztább annál, mint ahogy megtaláltuk.",
            "c. A tudás minden darabkájának egyetlen, egyértelmű és megbízható reprezentációval kell rendelkeznie egy rendszeren belül.",
            "d. Ne implementáljunk előre olyan kódot, ami „majd a jövőben kelleni fog”, mert szinte biztos, hogy sose lesz rá szükségünk."
        ],
        "question_counter": 111
    },
    {
        "question": "Melyik tervezési mintát alkalmazhatjuk abban az esetben, ha egy adott osztály példányosítását szeretnénk a hozzátartozó alosztályokra átruházni?",
        "correct_answer": "b",
        "options": [
            "a. Observer (Megfigyelő)",
            "b. Factory method (Gyártó függvény)",
            "c. Builder (Építő)",
            "d. Command (Parancs)"
        ],
        "question_counter": 112
    }
]